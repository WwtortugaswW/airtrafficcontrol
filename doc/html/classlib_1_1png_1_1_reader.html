<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Air traffic control: lib.png.Reader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Air traffic control
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>lib</b></li><li class="navelem"><b>png</b></li><li class="navelem"><a class="el" href="classlib_1_1png_1_1_reader.html">Reader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classlib_1_1png_1_1_reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lib.png.Reader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4f3aee6939d0cb1a6d978f9450b18fb3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a4f3aee6939d0cb1a6d978f9450b18fb3">__init__</a> (self, _guess=None, kw)</td></tr>
<tr class="separator:a4f3aee6939d0cb1a6d978f9450b18fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9802ec7e407d1ea9e5f69b9a0af1ed0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#ab9802ec7e407d1ea9e5f69b9a0af1ed0">chunk</a> (self, seek=None, lenient=False)</td></tr>
<tr class="separator:ab9802ec7e407d1ea9e5f69b9a0af1ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed162ed2796599df4983036954a5e077"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#aed162ed2796599df4983036954a5e077">chunks</a> (self)</td></tr>
<tr class="separator:aed162ed2796599df4983036954a5e077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af232a3eecd4d1644beba2d144feb76c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#af232a3eecd4d1644beba2d144feb76c7">undo_filter</a> (self, filter_type, scanline, previous)</td></tr>
<tr class="separator:af232a3eecd4d1644beba2d144feb76c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ec9a186e3fdf3a57601b3450ee0f5e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a19ec9a186e3fdf3a57601b3450ee0f5e">deinterlace</a> (self, raw)</td></tr>
<tr class="separator:a19ec9a186e3fdf3a57601b3450ee0f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9f2064e8d50af178d6e8d5aea74b47"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a5e9f2064e8d50af178d6e8d5aea74b47">iterboxed</a> (self, rows)</td></tr>
<tr class="separator:a5e9f2064e8d50af178d6e8d5aea74b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f04a6a71588837a20247ce4a34423f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a95f04a6a71588837a20247ce4a34423f">serialtoflat</a> (self, bytes, width=None)</td></tr>
<tr class="separator:a95f04a6a71588837a20247ce4a34423f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a25b00de431ed820a6624870aaff90"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a46a25b00de431ed820a6624870aaff90">iterstraight</a> (self, raw)</td></tr>
<tr class="separator:a46a25b00de431ed820a6624870aaff90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b26c3bd2f93d45ee288aee22b4ecfff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a7b26c3bd2f93d45ee288aee22b4ecfff">validate_signature</a> (self)</td></tr>
<tr class="separator:a7b26c3bd2f93d45ee288aee22b4ecfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9633656b8407495c98265f78ef92ad10"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a9633656b8407495c98265f78ef92ad10">preamble</a> (self, lenient=False)</td></tr>
<tr class="separator:a9633656b8407495c98265f78ef92ad10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf6dd680cba262114a176e79bfc8637"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a6cf6dd680cba262114a176e79bfc8637">chunklentype</a> (self)</td></tr>
<tr class="separator:a6cf6dd680cba262114a176e79bfc8637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bf1df6ac7fca542b8dc0d035009ce8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a26bf1df6ac7fca542b8dc0d035009ce8">process_chunk</a> (self, lenient=False)</td></tr>
<tr class="separator:a26bf1df6ac7fca542b8dc0d035009ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee96e12fc05a9024ebf916b1b90ac44"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#abee96e12fc05a9024ebf916b1b90ac44">read</a> (self, lenient=False)</td></tr>
<tr class="separator:abee96e12fc05a9024ebf916b1b90ac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cb36f6dfd5c54e426b56eddc28415d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a90cb36f6dfd5c54e426b56eddc28415d">read_flat</a> (self)</td></tr>
<tr class="separator:a90cb36f6dfd5c54e426b56eddc28415d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fbc2d1cdf23f0844ab0b40fe4f0803"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a68fbc2d1cdf23f0844ab0b40fe4f0803">palette</a> (self, alpha='natural')</td></tr>
<tr class="separator:a68fbc2d1cdf23f0844ab0b40fe4f0803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf97dda070dc0410c95f3873c30200a6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#adf97dda070dc0410c95f3873c30200a6">asDirect</a> (self)</td></tr>
<tr class="separator:adf97dda070dc0410c95f3873c30200a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096a287be3328813ad533c97b67d99a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a096a287be3328813ad533c97b67d99a0">asFloat</a> (self, maxval=1.0)</td></tr>
<tr class="separator:a096a287be3328813ad533c97b67d99a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f44e7d9394ce45fefe711cd1ac03b5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a69f44e7d9394ce45fefe711cd1ac03b5">asRGB8</a> (self)</td></tr>
<tr class="separator:a69f44e7d9394ce45fefe711cd1ac03b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3c246de50a87e148a43ba42f6faac0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a2e3c246de50a87e148a43ba42f6faac0">asRGBA8</a> (self)</td></tr>
<tr class="separator:a2e3c246de50a87e148a43ba42f6faac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca94eae486ee2820a2487a12c42a2c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a6ca94eae486ee2820a2487a12c42a2c0">asRGB</a> (self)</td></tr>
<tr class="separator:a6ca94eae486ee2820a2487a12c42a2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245e000fa789414e0caa35e98fae3f08"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlib_1_1png_1_1_reader.html#a245e000fa789414e0caa35e98fae3f08">asRGBA</a> (self)</td></tr>
<tr class="separator:a245e000fa789414e0caa35e98fae3f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af10c13c0fbb891fb53b0244572c68cf5"><td class="memItemLeft" align="right" valign="top"><a id="af10c13c0fbb891fb53b0244572c68cf5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>signature</b></td></tr>
<tr class="separator:af10c13c0fbb891fb53b0244572c68cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff2efbda2a138fa4db8f2f351397866"><td class="memItemLeft" align="right" valign="top"><a id="acff2efbda2a138fa4db8f2f351397866"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>transparent</b></td></tr>
<tr class="separator:acff2efbda2a138fa4db8f2f351397866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98818bb9983951973b9efb022bbc0e5a"><td class="memItemLeft" align="right" valign="top"><a id="a98818bb9983951973b9efb022bbc0e5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>atchunk</b></td></tr>
<tr class="separator:a98818bb9983951973b9efb022bbc0e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0af2cdd5d8faa2105b939a3440abdd"><td class="memItemLeft" align="right" valign="top"><a id="a4d0af2cdd5d8faa2105b939a3440abdd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>file</b></td></tr>
<tr class="separator:a4d0af2cdd5d8faa2105b939a3440abdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071bdb47606d36023d13ecd96afbfb76"><td class="memItemLeft" align="right" valign="top"><a id="a071bdb47606d36023d13ecd96afbfb76"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>bitdepth</b></td></tr>
<tr class="separator:a071bdb47606d36023d13ecd96afbfb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48ec8781d7daaf2778cb27e354dd08d"><td class="memItemLeft" align="right" valign="top"><a id="ac48ec8781d7daaf2778cb27e354dd08d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>colormap</b></td></tr>
<tr class="separator:ac48ec8781d7daaf2778cb27e354dd08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ece3733343ffa4b018507bd99de583"><td class="memItemLeft" align="right" valign="top"><a id="a47ece3733343ffa4b018507bd99de583"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>greyscale</b></td></tr>
<tr class="separator:a47ece3733343ffa4b018507bd99de583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf5abeb872a2ef12d95f3f82b47cc3d"><td class="memItemLeft" align="right" valign="top"><a id="aaaf5abeb872a2ef12d95f3f82b47cc3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>alpha</b></td></tr>
<tr class="separator:aaaf5abeb872a2ef12d95f3f82b47cc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad838dc377d9384395a48206118dba325"><td class="memItemLeft" align="right" valign="top"><a id="ad838dc377d9384395a48206118dba325"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>color_planes</b></td></tr>
<tr class="separator:ad838dc377d9384395a48206118dba325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd04b845de04ac0449b3454eb2654d52"><td class="memItemLeft" align="right" valign="top"><a id="afd04b845de04ac0449b3454eb2654d52"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>planes</b></td></tr>
<tr class="separator:afd04b845de04ac0449b3454eb2654d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42dab46728fa6dc6f8d802a1bba3f74b"><td class="memItemLeft" align="right" valign="top"><a id="a42dab46728fa6dc6f8d802a1bba3f74b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>psize</b></td></tr>
<tr class="separator:a42dab46728fa6dc6f8d802a1bba3f74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8959119a3485bb8f156776dcef51fe1"><td class="memItemLeft" align="right" valign="top"><a id="ab8959119a3485bb8f156776dcef51fe1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>row_bytes</b></td></tr>
<tr class="separator:ab8959119a3485bb8f156776dcef51fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109bee51b6befa0aba939358eb238b54"><td class="memItemLeft" align="right" valign="top"><a id="a109bee51b6befa0aba939358eb238b54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plte</b></td></tr>
<tr class="separator:a109bee51b6befa0aba939358eb238b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75480dedbc8a789e3f3a4e38e8285377"><td class="memItemLeft" align="right" valign="top"><a id="a75480dedbc8a789e3f3a4e38e8285377"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>trns</b></td></tr>
<tr class="separator:a75480dedbc8a789e3f3a4e38e8285377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48db770b0e7c0bf9b7e96a12c47d0c56"><td class="memItemLeft" align="right" valign="top"><a id="a48db770b0e7c0bf9b7e96a12c47d0c56"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sbit</b></td></tr>
<tr class="separator:a48db770b0e7c0bf9b7e96a12c47d0c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6bc9daae77e2e47ce994159bdcf917"><td class="memItemLeft" align="right" valign="top"><a id="a8e6bc9daae77e2e47ce994159bdcf917"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>background</b></td></tr>
<tr class="separator:a8e6bc9daae77e2e47ce994159bdcf917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7956a3dab9c08caf0f2325798ceb910b"><td class="memItemLeft" align="right" valign="top"><a id="a7956a3dab9c08caf0f2325798ceb910b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>gamma</b></td></tr>
<tr class="separator:a7956a3dab9c08caf0f2325798ceb910b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcc91567af9b456c02d68e167184505"><td class="memItemLeft" align="right" valign="top"><a id="aafcc91567af9b456c02d68e167184505"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>phys</b></td></tr>
<tr class="separator:aafcc91567af9b456c02d68e167184505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5f42711152bbb2455257bb61292d6d"><td class="memItemLeft" align="right" valign="top"><a id="a4e5f42711152bbb2455257bb61292d6d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>unit_is_meter</b></td></tr>
<tr class="separator:a4e5f42711152bbb2455257bb61292d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">PNG decoder in pure Python.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4f3aee6939d0cb1a6d978f9450b18fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3aee6939d0cb1a6d978f9450b18fb3">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_guess</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a PNG decoder object.

The constructor expects exactly one keyword argument. If you
supply a positional argument instead, it will guess the input
type. You can choose among the following keyword arguments:

filename
  Name of input file (a PNG file).
file
  A file-like object (object with a read() method).
bytes
  ``array`` or ``string`` with PNG data.</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adf97dda070dc0410c95f3873c30200a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf97dda070dc0410c95f3873c30200a6">&#9670;&nbsp;</a></span>asDirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.asDirect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the image data as a direct representation of an
``x * y * planes`` array.  This method is intended to remove the
need for callers to deal with palettes and transparency
themselves.  Images with a palette (colour type 3)
are converted to RGB or RGBA; images with transparency (a
``tRNS`` chunk) are converted to LA or RGBA as appropriate.
When returned in this format the pixel values represent the
colour value directly without needing to refer to palettes or
transparency information.

Like the :meth:`read` method this method returns a 4-tuple:

(*width*, *height*, *pixels*, *meta*)

This method normally returns pixel values with the bit depth
they have in the source image, but when the source PNG has an
``sBIT`` chunk it is inspected and can reduce the bit depth of
the result pixels; pixel values will be reduced according to
the bit depth specified in the ``sBIT`` chunk (PNG nerds should
note a single result bit depth is used for all channels; the
maximum of the ones specified in the ``sBIT`` chunk.  An RGB565
image will be rescaled to 6-bit RGB666).

The *meta* dictionary that is returned reflects the `direct`
format and not the original source image.  For example, an RGB
source image with a ``tRNS`` chunk to represent a transparent
colour, will have ``planes=3`` and ``alpha=False`` for the
source image, but the *meta* dictionary returned by this method
will have ``planes=4`` and ``alpha=True`` because an alpha
channel is synthesized and added.

*pixels* is the pixel data in boxed row flat pixel format (just
like the :meth:`read` method).

All the other aspects of the image data are not changed.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_adf97dda070dc0410c95f3873c30200a6_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_adf97dda070dc0410c95f3873c30200a6_cgraph" alt=""/></div>
<!-- MAP 0 -->
</div>

</div>
</div>
<a id="a096a287be3328813ad533c97b67d99a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096a287be3328813ad533c97b67d99a0">&#9670;&nbsp;</a></span>asFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.asFloat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxval</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return image pixels as per :meth:`asDirect` method, but scale
all pixel values to be floating point values between 0.0 and
*maxval*.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a096a287be3328813ad533c97b67d99a0_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a096a287be3328813ad533c97b67d99a0_cgraph" alt=""/></div>
<!-- MAP 1 -->
</div>

</div>
</div>
<a id="a6ca94eae486ee2820a2487a12c42a2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca94eae486ee2820a2487a12c42a2c0">&#9670;&nbsp;</a></span>asRGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.asRGB </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return image as RGB pixels.  RGB colour images are passed
through unchanged; greyscales are expanded into RGB
triplets (there is a small speed overhead for doing this).

An alpha channel in the source image will raise an
exception.

The return values are as for the :meth:`read` method
except that the *metadata* reflect the returned pixels, not the
source image.  In particular, for this method
``metadata['greyscale']`` will be ``False``.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a6ca94eae486ee2820a2487a12c42a2c0_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a6ca94eae486ee2820a2487a12c42a2c0_cgraph" alt=""/></div>
<!-- MAP 2 -->
</div>

</div>
</div>
<a id="a69f44e7d9394ce45fefe711cd1ac03b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f44e7d9394ce45fefe711cd1ac03b5">&#9670;&nbsp;</a></span>asRGB8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.asRGB8 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the image data as an RGB pixels with 8-bits per
sample.  This is like the :meth:`asRGB` method except that
this method additionally rescales the values so that they
are all between 0 and 255 (8-bit).  In the case where the
source image has a bit depth &lt; 8 the transformation preserves
all the information; where the source image has bit depth
&gt; 8, then rescaling to 8-bit values loses precision.  No
dithering is performed.  Like :meth:`asRGB`, an alpha channel
in the source image will raise an exception.

This function returns a 4-tuple:
(*width*, *height*, *pixels*, *metadata*).
*width*, *height*, *metadata* are as per the
:meth:`read` method.

*pixels* is the pixel data in boxed row flat pixel format.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a69f44e7d9394ce45fefe711cd1ac03b5_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a69f44e7d9394ce45fefe711cd1ac03b5_cgraph" alt=""/></div>
<!-- MAP 3 -->
</div>

</div>
</div>
<a id="a245e000fa789414e0caa35e98fae3f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245e000fa789414e0caa35e98fae3f08">&#9670;&nbsp;</a></span>asRGBA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.asRGBA </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return image as RGBA pixels.  Greyscales are expanded into
RGB triplets; an alpha channel is synthesized if necessary.
The return values are as for the :meth:`read` method
except that the *metadata* reflect the returned pixels, not the
source image.  In particular, for this method
``metadata['greyscale']`` will be ``False``, and
``metadata['alpha']`` will be ``True``.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a245e000fa789414e0caa35e98fae3f08_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a245e000fa789414e0caa35e98fae3f08_cgraph" alt=""/></div>
<!-- MAP 4 -->
</div>

</div>
</div>
<a id="a2e3c246de50a87e148a43ba42f6faac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3c246de50a87e148a43ba42f6faac0">&#9670;&nbsp;</a></span>asRGBA8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.asRGBA8 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the image data as RGBA pixels with 8-bits per
sample.  This method is similar to :meth:`asRGB8` and
:meth:`asRGBA`:  The result pixels have an alpha channel, *and*
values are rescaled to the range 0 to 255.  The alpha channel is
synthesized if necessary (with a small speed penalty).
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a2e3c246de50a87e148a43ba42f6faac0_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a2e3c246de50a87e148a43ba42f6faac0_cgraph" alt=""/></div>
<!-- MAP 5 -->
</div>

</div>
</div>
<a id="ab9802ec7e407d1ea9e5f69b9a0af1ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9802ec7e407d1ea9e5f69b9a0af1ed0">&#9670;&nbsp;</a></span>chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.chunk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seek</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read the next PNG chunk from the input file; returns a
(*type*, *data*) tuple.  *type* is the chunk's type as a
byte string (all PNG chunk types are 4 bytes long).
*data* is the chunk's data content, as a byte string.

If the optional `seek` argument is
specified then it will keep reading chunks until it either runs
out of file or finds the type specified by the argument.  Note
that in general the order of chunks in PNGs is unspecified, so
using `seek` can cause you to miss chunks.

If the optional `lenient` argument evaluates to `True`,
checksum failures will raise warnings rather than exceptions.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_ab9802ec7e407d1ea9e5f69b9a0af1ed0_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_ab9802ec7e407d1ea9e5f69b9a0af1ed0_cgraph" alt=""/></div>
<!-- MAP 6 -->
</div>

</div>
</div>
<a id="a6cf6dd680cba262114a176e79bfc8637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf6dd680cba262114a176e79bfc8637">&#9670;&nbsp;</a></span>chunklentype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.chunklentype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reads just enough of the input to determine the next
chunk's length and type, returned as a (*length*, *type*) pair
where *type* is a string.  If there are no more chunks, ``None``
is returned.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a6cf6dd680cba262114a176e79bfc8637_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a6cf6dd680cba262114a176e79bfc8637_cgraph" alt=""/></div>
<!-- MAP 7 -->
</div>

</div>
</div>
<a id="aed162ed2796599df4983036954a5e077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed162ed2796599df4983036954a5e077">&#9670;&nbsp;</a></span>chunks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.chunks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an iterator that will yield each chunk as a
(*chunktype*, *content*) pair.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_aed162ed2796599df4983036954a5e077_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_aed162ed2796599df4983036954a5e077_cgraph" alt=""/></div>
<!-- MAP 8 -->
</div>

</div>
</div>
<a id="a19ec9a186e3fdf3a57601b3450ee0f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ec9a186e3fdf3a57601b3450ee0f5e">&#9670;&nbsp;</a></span>deinterlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.deinterlace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read raw pixel data, undo filters, deinterlace, and flatten.
Return in flat row flat pixel format.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a19ec9a186e3fdf3a57601b3450ee0f5e_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a19ec9a186e3fdf3a57601b3450ee0f5e_cgraph" alt=""/></div>
<!-- MAP 9 -->
</div>

</div>
</div>
<a id="a5e9f2064e8d50af178d6e8d5aea74b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9f2064e8d50af178d6e8d5aea74b47">&#9670;&nbsp;</a></span>iterboxed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.iterboxed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterator that yields each scanline in boxed row flat pixel
format.  `rows` should be an iterator that yields the bytes of
each row in turn.
</pre> 
</div>
</div>
<a id="a46a25b00de431ed820a6624870aaff90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a25b00de431ed820a6624870aaff90">&#9670;&nbsp;</a></span>iterstraight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.iterstraight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterator that undoes the effect of filtering, and yields
each row in serialised format (as a sequence of bytes).
Assumes input is straightlaced.  `raw` should be an iterable
that yields the raw bytes in chunks of arbitrary size.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a46a25b00de431ed820a6624870aaff90_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a46a25b00de431ed820a6624870aaff90_cgraph" alt=""/></div>
<!-- MAP 10 -->
</div>

</div>
</div>
<a id="a68fbc2d1cdf23f0844ab0b40fe4f0803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fbc2d1cdf23f0844ab0b40fe4f0803">&#9670;&nbsp;</a></span>palette()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.palette </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>'natural'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a palette that is a sequence of 3-tuples or 4-tuples,
synthesizing it from the ``PLTE`` and ``tRNS`` chunks.  These
chunks should have already been processed (for example, by
calling the :meth:`preamble` method).  All the tuples are the
same size: 3-tuples if there is no ``tRNS`` chunk, 4-tuples when
there is a ``tRNS`` chunk.  Assumes that the image is colour type
3 and therefore a ``PLTE`` chunk is required.

If the `alpha` argument is ``'force'`` then an alpha channel is
always added, forcing the result to be a sequence of 4-tuples.
</pre> 
</div>
</div>
<a id="a9633656b8407495c98265f78ef92ad10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9633656b8407495c98265f78ef92ad10">&#9670;&nbsp;</a></span>preamble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.preamble </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract the image metadata by reading the initial part of
the PNG file up to the start of the ``IDAT`` chunk.  All the
chunks that precede the ``IDAT`` chunk are read and either
processed for metadata or discarded.

If the optional `lenient` argument evaluates to `True`, checksum
failures will raise warnings rather than exceptions.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a9633656b8407495c98265f78ef92ad10_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a9633656b8407495c98265f78ef92ad10_cgraph" alt=""/></div>
<!-- MAP 11 -->
</div>

</div>
</div>
<a id="a26bf1df6ac7fca542b8dc0d035009ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bf1df6ac7fca542b8dc0d035009ce8">&#9670;&nbsp;</a></span>process_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.process_chunk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Process the next chunk and its data.  This only processes the
following chunk types, all others are ignored: ``IHDR``,
``PLTE``, ``bKGD``, ``tRNS``, ``gAMA``, ``sBIT``, ``pHYs``.

If the optional `lenient` argument evaluates to `True`,
checksum failures will raise warnings rather than exceptions.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a26bf1df6ac7fca542b8dc0d035009ce8_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a26bf1df6ac7fca542b8dc0d035009ce8_cgraph" alt=""/></div>
<!-- MAP 12 -->
</div>

</div>
</div>
<a id="abee96e12fc05a9024ebf916b1b90ac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee96e12fc05a9024ebf916b1b90ac44">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.read </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read the PNG file and decode it.  Returns (`width`, `height`,
`pixels`, `metadata`).

May use excessive memory.

`pixels` are returned in boxed row flat pixel format.

If the optional `lenient` argument evaluates to True,
checksum failures will raise warnings rather than exceptions.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_abee96e12fc05a9024ebf916b1b90ac44_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_abee96e12fc05a9024ebf916b1b90ac44_cgraph" alt=""/></div>
<!-- MAP 13 -->
</div>

</div>
</div>
<a id="a90cb36f6dfd5c54e426b56eddc28415d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cb36f6dfd5c54e426b56eddc28415d">&#9670;&nbsp;</a></span>read_flat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.read_flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a PNG file and decode it into flat row flat pixel format.
Returns (*width*, *height*, *pixels*, *metadata*).

May use excessive memory.

`pixels` are returned in flat row flat pixel format.

See also the :meth:`read` method which returns pixels in the
more stream-friendly boxed row flat pixel format.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a90cb36f6dfd5c54e426b56eddc28415d_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a90cb36f6dfd5c54e426b56eddc28415d_cgraph" alt=""/></div>
<!-- MAP 14 -->
</div>

</div>
</div>
<a id="a95f04a6a71588837a20247ce4a34423f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f04a6a71588837a20247ce4a34423f">&#9670;&nbsp;</a></span>serialtoflat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.serialtoflat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert serial format (byte stream) pixel data to flat row
flat pixel.
</pre> 
</div>
</div>
<a id="af232a3eecd4d1644beba2d144feb76c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af232a3eecd4d1644beba2d144feb76c7">&#9670;&nbsp;</a></span>undo_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.undo_filter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filter_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scanline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>previous</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Undo the filter for a scanline.  `scanline` is a sequence of
bytes that does not include the initial filter type byte.
`previous` is decoded previous scanline (for straightlaced
images this is the previous pixel row, but for interlaced
images, it is the previous scanline in the reduced image, which
in general is not the previous pixel row in the final image).
When there is no previous scanline (the first row of a
straightlaced image, or the first row in one of the passes in an
interlaced image), then this argument should be ``None``.

The scanline will have the effects of filtering removed, and the
result will be returned as a fresh sequence of bytes.
</pre> 
</div>
</div>
<a id="a7b26c3bd2f93d45ee288aee22b4ecfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b26c3bd2f93d45ee288aee22b4ecfff">&#9670;&nbsp;</a></span>validate_signature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lib.png.Reader.validate_signature </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If signature (header) has not been read then read and
validate it; otherwise do nothing.
</pre> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlib_1_1png_1_1_reader_a7b26c3bd2f93d45ee288aee22b4ecfff_cgraph.png" border="0" usemap="#classlib_1_1png_1_1_reader_a7b26c3bd2f93d45ee288aee22b4ecfff_cgraph" alt=""/></div>
<!-- MAP 15 -->
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/appJar/lib/png.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
